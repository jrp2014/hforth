\ : immediate _read @ ! - * / <0 exit echo key _pick

: debug immediate 1 5 ! ;

: r 1 ;

: ] r @ 1 - r ! _read ] ;

: _main immediate r @ 7 ! ] ;
\ _main


: _x 3 @ ;
: _y 4 @ ;
: _x! 3 ! ;
: _y! 4 ! ;


: bswap _x! _y! _x _y ;

: + 0 bswap - - ;

: bdup _x! _x _x ;

: inc bdup @ 1 + bswap ! ;

: h 0 ;

: , h @ ! h inc ;


: b' r @ @ bdup 1 + r @ ! @ ;

\ : ; immediate b' exit , ;


: bdrop 0 * + ;

: dec bdup @ 1 - bswap ! ;

: tor r @ @ bswap r @ ! r @ 1 + r ! r @ ! ;

: fromr r @ @ r @ 1 - r ! r @ @ bswap r @ ! ;

: tail fromr fromr bdrop tor ;

: minus 0 bswap - ;

: bnot 1 bswap - ;

: < - <0 ;

: logical bdup 0 < bswap minus 0 < + ;

: not logical bnot ;

: = - not ;

: branch r @ @ @ r @ @ + r @ ! ;

: computebranch 1 - * 1 + ;

: notbranch
  not
  r @ @ @
  computebranch
  r @ @ +
  r @ !
;

: here h @ ;

: bif immediate b' notbranch , here 0 , ;

: bthen immediate bdup here bswap - bswap ! ;

: ')' 0 ;

: _fix key bdrop key bswap 2 + ! ;

: fix-')' immediate b' ')' _fix ;

\ fix-')' )

: find-) key ')' = not bif tail find-) bthen ;

\ : ( immediate find-) ;

( we should be able to do FORTH-style comments now )

( this works as follows: ( is an immediate word, so it gets
  control during compilation.  Then it simply reads in characters
  until it sees a close parenthesis.  once it does, it exits.
  bif not, it pops off the return stack--manual tail recursion. )

( now that we've got comments, we can comment the rest of the code! )

: belse immediate
  b' branch ,		( compile a definite branch )
  here			( push the backpatching address )
  0 ,			( compile a dummy offset for branch )
  bswap			( bring old backpatch address to top )
  bdup here bswap -	( calculate the offset from old address )
  bswap !		( put the address on top and store it )
;

: bover _x! _y! _y _x _y ;

: add
  _x!			( save the pointer in a temp variable )
  _x @			( get the value pointed to )
  +			( add the incremement from on top of the stack )
  _x !			( and save it )
;

: allot	h add ;

: maybebranch
  logical		( force the TOS to be 0 or 1 )
  r @ @ @		( load the branch offset )
  computebranch	( calculate the condition offset [either TOS or 1])
  r @ @ +		( add it to the return address )
  r @ !		( store it to our return address and return )
;

: mod _x! _y!		( get x bthen y off of stack )
  _y
  _y _x / _x *		( y - y / x * x )
  -
;

: '\n' 0 ;
: b'"' 0 ;
: b'0' 0 ;
: 'space' 0 ;

: fix-'\n' immediate b' '\n' _fix ;
: fix-'"' immediate b' b'"' _fix ;
: fix-'0' immediate b' b'0' _fix ;
: fix-'space' immediate b' 'space' _fix ;

\ fix-'0' 0 fix-'space'  fix-'"' '"'
\ fix-'\n'


: cr '\n' echo ;

: printnum
  bdup
  10 mod '0' +
  bswap 10 / bdup
  bif
    printnum 0
  bthen
  bdrop echo
;

: b.
  bdup 0 <
  bif
    45 echo minus
  bthen
  printnum
  'space' echo
;


: debugprint bdup b. cr ;

( the following routine takes a pointer to a string, and prints it,
  except for the trailing quote.  returns a pointer to the next word
  after the trailing quote )

: _print
  bdup 1 +
  bswap @
  bdup '"' =
  bif
    bdrop exit
  bthen
  echo
  tail _print
;

: print _print ;

  ( print the next thing from the instruction stream )
: immprint
  r @ @
  print
  r @ !
;

: find-"
  key bdup ,
  '"' =
  bif
    exit
  bthen
  tail find-"
;

: " immediate
  key bdrop
  b' immprint ,
  find-"
;

: bdo immediate
  b' bswap ,		( compile 'bswap' to bswap the limit and start )
  b' tor ,		( compile to push the limit onto the return stack )
  b' tor ,		( compile to push the start on the return stack )
  here			( save this address so we can branch back to it )
;

: bi r @ 1 - @ ;
: bj r @ 3 - @ ;

: > bswap < ;
: <= 1 + < ;
: >= bswap <= ;

: inci 
  r @ 1 - 	( get the pointer to bi )
  inc		( add one to it )
  r @ 1 - @ 	( find the value again )
  r @ 2 - @	( find the limit value )
  <
  bif
    r @ @ @ r @ @ + r @ ! exit		( branch )
  bthen
  fromr 1 +
  fromr bdrop
  fromr bdrop
  tor
;
  	
: bloop immediate b' inci , here - , ;

: loopexit

  fromr bdrop		( pop off our return address )
  fromr bdrop		( pop off bi )
  fromr bdrop		( pop off the limit of bi )
;			( and return to the caller's caller routine )

: isprime
  bdup 2 = bif
    exit
  bthen
  bdup 2 / 2		( bloop from 2 to n/2 )
  bdo
    bdup			( value we're checking bif it's prime )
    bi mod		( mod it by divisor )
    not bif
      bdrop 0 loopexit	( exit from routine from inside bloop )
    bthen
  bloop 
;

: primes
  s" The primes from "
  bdup .
  s"  to "
  bover .
  s"  are:"
  cr

  bdo
    bi isprime 
    bif
      bi b. 'space' echo
    bthen
  bloop
  cr
;

: bexecute
  8 !
  b' exit 9 !
  8 tor
;

: :: ;		( :: is going to be a word that does ':' at runtime )

: fix-:: immediate 3 b' :: ! ;
fix-::

	( Override old definition of ':' with a new one that invokes ] )
\ : : immediate :: ] ;

: command
  here 5 !		( store dict pointer in temp variable )
  _read			( compile a word )
			( bif we get control back: )
  here 5 @
  = bif
    tail command	( we didn't compile anything )
  bthen
  here 1 - h !		( decrement the dictionary pointer )
  here 5 @		( get the original value )
  = bif
    here @		( get the word that was compiled )
    bexecute		( and run it )
  belse
    here @		( belse it was an integer constant, so push it )
    here 1 - h !	( and decrement the dictionary pointer again )
  bthen
  tail command
;

: make-immediate	( make a word just compiled immediate )
  here 1 -		( back up a word in the dictionary )
  bdup bdup		( save the pointer to here )
  h !			( store as the current dictionary pointer )
  @			( get the run-time code pointer )
  bswap			( get the dict pointer again )
  1 -			( point to the compile-time code pointer )
  !			( write run-time code pointer on compile-time pointer )
;

: <build immediate
  make-immediate	( make the word compiled so far immediate )
  b' :: ,		( compile '::', so we read next word )
  2 ,			( compile 'pushint' )
  here 0 ,		( write out a 0 but save address for does> )
  b' , ,			( compile a push that address onto dictionary )
;

: does> immediate
  b' command ,		( jump back into command mode at runtime )
  here bswap !		( backpatch the build> to point to here )
  2 ,			( compile run-code primitive so we look like a word )
  b' fromr ,		( compile fromr, which leaves var address on stack )
;


: _dump			( dump out the definition of a word, sort of )
  bdup s" (" b. s" , "
  bdup @			( save the pointer and get the contents )
  bdup b' exit
  = bif
	s" ;)" cr exit
  bthen
  b. s" ), "
  1 +
  tail _dump
;

: dump _dump ;

: # b. cr ;
  
: var <build , does> ;
: constant <build , does> @ ;
: array <build allot does> + ;

: [ immediate command ;
: _welcome s" Welcome to THIRD.
Ok.
" ;

\ : ; immediate b' exit , command exit

\ [

_welcome
